\documentclass[12pt,a4paper]{article}
\usepackage[margin=1in, includeheadfoot]{geometry}

\usepackage[dvipsnames]{xcolor}

\usepackage[dvipsnames]{xcolor}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{makeidx}
\usepackage{thmtools}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{algpseudocode}
\usepackage{multirow}


\usetikzlibrary{positioning}

\usepackage{thmtools}
\usepackage[skip=6pt]{parskip}

\usepackage{fancyhdr}
\pagestyle{fancy}

\fancyhead[L]{\textbf{KOY is not UC-Secure}}
\fancyhead[R]{\thepage}
\fancyfoot{}

\setlength\parindent{0pt}

\hypersetup{
	colorlinks=true,
	linkcolor=red,
	filecolor=red,  
	citecolor=red,    
	urlcolor=blue,
	pdftitle={Games on Graphs \#1},
	pdfpagemode=FullScreen,
}

\usepackage[framemethod=tikz]{mdframed}

\declaretheorem[name=Theorem, numberwithin=section]{theorem}
\declaretheorem[name=Lemma, numberwithin=section]{lemma}
\declaretheorem[name=Inequality, numberwithin=section]{inequality}
\declaretheorem[name=Definition, numberwithin=section]{definition}

\usepackage[english]{babel}
\title{\textbf{KOY is not UC-Secure}}
\author{Naman Kumar}

%------- General Macros

\newcommand{\np}{\mathbf{NP}}
\newcommand{\p}{\mathbf{P}}
\newcommand{\ip}{\mathbf{IP}}
\newcommand{\pspace}{\mathbf{PSPACE}}
\newcommand{\am}{\mathbf{AM}}
\newcommand{\ma}{\mathbf{MA}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\E}{\mathbb{E}}
\newcommand{\rel}{\mathcal{R}}
\newcommand{\lang}{\mathcal{L}}
\newcommand{\query}{\mathcal{Q}}
\newcommand{\prover}{\mathcal{P}}
\newcommand{\verifier}{\mathcal{V}}
\newcommand{\decision}{\mathcal{D}}
\newcommand{\simulator}{\mathcal{S}}
\newcommand{\sat}{\mathsf{SAT}}
\newcommand{\nc}{\mathbf{NC}}
\newcommand{\hvzk}{\mathbf{HVZK}}
\newcommand{\zk}{\mathbf{ZK}}
\newcommand{\pzk}{\mathbf{PZK}}
\newcommand{\czk}{\mathbf{CZK}}
\newcommand{\szk}{\mathbf{SZK}}
\newcommand{\pc}{\mathsf{pc}}
\newcommand{\vc}{\mathsf{vc}}
\newcommand{\vr}{\mathsf{vr}}
\newcommand{\poly}{\mathsf{poly}}
\newcommand{\add}{\mathsf{add}}
\newcommand{\mul}{\mathsf{mul}}
\newcommand{\view}{\mathsf{View}}
\newcommand{\trace}{\textsc{Trace}}
\newcommand{\bpp}{\mathbf{BPP}}
\newcommand{\hilbert}{\mathcal{H}}
\newcommand{\ket}[1]{\left|#1\right\rangle}
\newcommand{\bra}[1]{\left\langle#1\right|}
\newcommand{\braket}[2]{\langle#1|#2\rangle}
\newcommand{\puncture}{\mathsf{Puncture}}

%---------- Macros

\newcommand{\env}{\mathcal{Z}}
\newcommand{\adv}{\mathcal{A}}
\newcommand{\pake}{\mathcal{F}_{\mathsf{PAKE}}}
\newcommand{\user}{\mathsf{User}}
\newcommand{\sk}{\mathsf{sk}}
\newcommand{\pw}{\mathsf{pw}}
\newcommand{\crs}{\mathsf{crs}}
\newcommand{\newsession}{\mathsf{NewSession}}
\newcommand{\testpwd}{\mathsf{TestPwd}}
\newcommand{\server}{\mathsf{Server}}
\newcommand{\msg}[1]{\mathsf{msg}_{#1}}


\begin{document}
	\maketitle
	
	This document contains a proof that the PAKE protocol of Katz, Ostrovsky and Yung (2001) is not UC-secure.
	
	\section{Overview}
	
	At a high level, our attack relies on an adversary that completely disregards the presence of the $\server$ and instead interacts with the $\user$ while executing the Server's algorithm on its own. In particular, once the protocol is initiated by $\user$, the adversary assumes the role of the server (discarding the actual server in the process, which plays no part in the protocol henceforth) and recieves $\msg{1}$. After this, $\adv$ is provided the messages $E|F|G|H|I|J$ by $\env$ which it then forwards to $\user$. $\user$ can then run its own session-key generating algorithm (the computation of $E^{r_1}F^{x_1}G^{y_1}(I')^{z_1}J^{w_1})$ and output the session key $\sk$. We note that at this point, $\adv$ and $\env$ have all the information they need to run the server algorithm and ensure that their generated session key is equal to the $\sk$ generated by $\user$.
	
	To see why $\simulator$ cannot simulate this adversary, we attempt an ideal-world execution and pinpoint where our simulation fails. Since $\simulator$ is allowed to choose the $\crs$, it can sample $g_1$ at random and set $h$ such that $h={g_1}^{\ell}$. After receiving the $\newsession$ command from $\pake$, $\simulator$ must simulate the $\user$ by sampling fresh randomness and computing $\msg{1}$. Since $\simulator$ does not know the password at this point it must guess some $\pw^{*}$ at random. Thus, in $\msg{1}$, $C=h^{r_1}\cdot\pw^{*}$ where $\pw^{*}$ can be no better than a random password sampled from the dictionary. $\simulator$ must then forward this message to $\env$ which responds with $E|F|G|I|J$ where  $\pw$ can be determined as $I/F^\ell$. Once this has been done, $\simulator$ can run a $\testpwd$ which would successfully allow it to choose the $\sk$ output by $\user$ (recall that a $\testpwd$ \textit{must} be run, since we require that $\msg{1}$ and $\msg{2}$ together with the randomness of the $\user$ and $\adv$ together determine $\sk$; allowing the simulation to proceed without a $\testpwd$ would result in $\pake$ outputting a uniformly random key). The problem is that even with this information, $\simulator$ can still not determine what $\sk$ is.
	
	To determine $\sk$, $\simulator$ can either run $\server$'s algorithm or $\user$'s algorithm to generate session keys. Recalling that $E|F|G|I|J$ is provided to $\simulator$ directly from the environment, $\simulator$ cannot use $\server$'s algorithm since it would require the determination of all of $x_2, y_2, z_2, r_2, w_2$, which is computationally infeasible under the hardness of CDH. Alternately, $\simulator$ can run $\user$'s algorithm to determine $\sk$, for which it already has access to $x_1,y_1,z_1,r_1,w_1$ and $E,F,G,I,J$. However, we require that this $\sk$ output by the $\simulator$ must be equal to that which $\env$ determines using its own execution of the $\server$'s algorithm ($\env$ knows the randomness generated in the construction of $E|F|G|I|J$ and can thus run this algorithm). We can show that the output of the server's algorithm on $\msg{1},\msg{2}$ and $\msg{3}$ by $\env$ will have $(\pw^{*}/pw)^{z_2}$ as a factor. Except in the $1/\mathcal{D}$ probability case that $\pw^{*}=\pw$, $\simulator$ cannot determine $z_2$ assuming the hardness of CDH and thus will be unable to determine $\sk$.
	
	
	
	\pagebreak
	\appendix
	
%	\bibliographystyle{alpha}
%	\bibliography{references}
	
\end{document}









