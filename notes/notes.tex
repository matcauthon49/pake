\documentclass[12pt,a4paper]{article}
\usepackage[margin=1in, includeheadfoot]{geometry}

\usepackage[dvipsnames]{xcolor}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
%\usepackage{makeidx}
\usepackage{thmtools}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{algpseudocode}
\usepackage{multirow}
\usepackage{framed}
\usepackage{cleveref} % allow for \cref command


\usetikzlibrary{positioning}

\usepackage{thmtools}
%\usepackage[skip=6pt]{parskip}

\usepackage{fancyhdr}
\pagestyle{fancy}

\fancyhead[L]{\textbf{KOY is not UC-Secure}}
\fancyhead[R]{\thepage}
\fancyfoot{}

\setlength\parindent{0pt}

\hypersetup{
	colorlinks=true,
	linkcolor=red,
	filecolor=red,  
	citecolor=red,    
	urlcolor=blue,
	pdftitle={Games on Graphs \#1},
	pdfpagemode=FullScreen,
}

% \usepackage[framemethod=tikz]{mdframed}

\declaretheorem[name=Theorem, numberwithin=section]{theorem}
\declaretheorem[name=Lemma, numberwithin=section]{lemma}
\declaretheorem[name=Inequality, numberwithin=section]{inequality}
\declaretheorem[name=Definition, numberwithin=section]{definition}

\usepackage[english]{babel}
\title{\textbf{KOY is not UC-Secure}}
\author{Naman Kumar}

%------- General Macros

\newcommand{\np}{\mathbf{NP}}
\newcommand{\p}{\mathbf{P}}
\newcommand{\ip}{\mathbf{IP}}
\newcommand{\pspace}{\mathbf{PSPACE}}
\newcommand{\am}{\mathbf{AM}}
\newcommand{\ma}{\mathbf{MA}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\E}{\mathbb{E}}
\newcommand{\rel}{\mathcal{R}}
\newcommand{\lang}{\mathcal{L}}
\newcommand{\query}{\mathcal{Q}}
\newcommand{\prover}{\mathcal{P}}
\newcommand{\verifier}{\mathcal{V}}
\newcommand{\decision}{\mathcal{D}}
\newcommand{\simulator}{\mathcal{S}}
\newcommand{\sat}{\mathsf{SAT}}
\newcommand{\nc}{\mathbf{NC}}
\newcommand{\hvzk}{\mathbf{HVZK}}
\newcommand{\zk}{\mathbf{ZK}}
\newcommand{\pzk}{\mathbf{PZK}}
\newcommand{\czk}{\mathbf{CZK}}
\newcommand{\szk}{\mathbf{SZK}}
\newcommand{\pc}{\mathsf{pc}}
\newcommand{\vc}{\mathsf{vc}}
\newcommand{\vr}{\mathsf{vr}}
\newcommand{\poly}{\mathsf{poly}}
\newcommand{\add}{\mathsf{add}}
\newcommand{\mul}{\mathsf{mul}}
\newcommand{\view}{\mathsf{View}}
\newcommand{\trace}{\textsc{Trace}}
\newcommand{\bpp}{\mathbf{BPP}}
\newcommand{\hilbert}{\mathcal{H}}
\newcommand{\ket}[1]{\left|#1\right\rangle}
\newcommand{\bra}[1]{\left\langle#1\right|}
\newcommand{\braket}[2]{\langle#1|#2\rangle}
\newcommand{\puncture}{\mathsf{Puncture}}

%---------- Macros

\newcommand{\env}{\mathcal{Z}}
\newcommand{\adv}{\mathcal{A}}
\newcommand{\pake}{\mathcal{F}_{\mathsf{PAKE}}}
\newcommand{\user}{\mathsf{User}}
\newcommand{\sk}{\mathsf{sk}}
\newcommand{\pw}{\mathsf{pw}}
\newcommand{\crs}{\mathsf{crs}}
\newcommand{\newsession}{\mathsf{NewSession}}
\newcommand{\testpwd}{\mathsf{TestPwd}}
\newcommand{\compromised}{\mathsf{compromised}}
\newcommand{\server}{\mathsf{Server}}
\newcommand{\msg}[1]{\mathsf{msg}_{#1}}
\newcommand{\rgets}{\xleftarrow{\$}}

\def\xjy#1{\textcolor{blue}{Jiayu: #1}}
\def\nam#1{\textcolor{red}{Naman: #1}}

\begin{document}
	\maketitle
	
	This document contains a proof that the PAKE protocol of Katz, Ostrovsky and Yung (2001) is not UC-secure.
	
	\section{Overview}
	
	At a high level, our attack relies on an adversary $\adv$ that completely disregards the presence of $\server$ and instead interacts with $\user$ while executing $\server$'s algorithm on its own. In particular, once the protocol is initiated by $\user$, $\adv$ assumes the role of the server (discarding the actual server in the process, which plays no part in the protocol henceforth) and receives $\msg{1} = \mathsf{VK}|A|B|C|D$. After this, $\adv$ runs the server's algorithm on the correct password $\pw$ and computes $\msg{2} = E|F|G|I|J$. $\user$ then runs its session-key generating algorithm and outputs its session key $\sk = E^{r_1}F^{x_1}G^{y_1}(I')^{z_1}J^{w_1}$. We note that at this point, $\adv$ (and $\env$) have all the information they need to run the server's session-key generating algorithm and ensure that their generated session key is equal to the $\sk$ generated by $\user$.\\
	
	To see why a simulator $\simulator$ cannot simulate this adversary, we attempt an ideal-world execution and pinpoint where our simulation fails. Since $\simulator$ is allowed to choose $\crs=(\mathbb{G}; g_1, g_2, h, c, d\in\mathbb{G}; H:\{0,1\}^{*}\rightarrow\mathbb{Z}_q)$, it can sample $g_1$ at random and set $h$ such that $h=g_1^{\ell}$. After receiving the $\newsession$ command from $\pake$, $\simulator$ must simulate $\user$'s first message $\msg{1}$. Since $\simulator$ does not know the password at this point it must (effectively) guess some $\pw^*$ at random; that is, in $\msg{1}$, $C=h^{r_1}\cdot\pw^*$ where $\pw^*$ can be no better than a random password sampled from the dictionary. After $\env$ responds with $\msg{2} = E|F|G|I|J$, $\simulator$ can extract $\pw$ as $I/F^\ell$. Once this has been done, $\simulator$ can send a $\testpwd$ command to $\pake$ which would mark the $\user$ session $\compromised$ and thus allow $\simulator$ to successfully choose the $\sk$ output by $\user$.\footnote{Recall that a $\testpwd$ \textit{must} be run, since we require that $\msg{1}$ and $\msg{2}$ together with the randomness of the $\user$ and $\adv$ together determine $\sk$; allowing the simulation to proceed without a $\testpwd$ would result in $\pake$ outputting a uniformly random key.} The problem is that even with this information, $\simulator$ still cannot determine what $\sk$ is.\\
	
	To determine $\sk$, $\simulator$ can either run $\server$'s algorithm or $\user$'s algorithm to generate session keys. Recalling that $\msg{2} = E|F|G|I|J$ is provided to $\simulator$ directly from the environment, $\simulator$ cannot use $\server$'s algorithm since it would require the determination of all of $x_2, y_2, z_2, r_2, w_2$, which is computationally infeasible under the hardness of CDH. Alternately, $\simulator$ can run $\user$'s algorithm to determine $\sk$, for which it already has access to $x_1,y_1,z_1,r_1,w_1$ and $E,F,G,I,J$. However, we recall that this $\sk$ output by $\simulator$ must be equal to that which $\env$ determines using its own execution of $\server$'s algorithm (this is what happens in the real world). The problem here is that the password guess $\pw^*$ that $\simulator$ uses while generating $\msg{1}$ is likely incorrect; in fact, we can show that the output of $\server$'s algorithm on $\msg{1},\msg{2}$ and $\msg{3}$ by $\env$ will have $(\pw^{*}/\pw)^{z_2}$ as a factor, and except in the $1/\mathcal{|D|}$ probability case that $\pw^*=\pw$, $\simulator$ cannot determine $z_2$ assuming the hardness of CDH and thus will be unable to determine $\sk$.\\
	
	\section{Proof}

%\xjy{Give a theorem statement first}

	\begin{theorem}
		Assuming the hardness of fixed-CDH, the protocol of [KOY] does not UC-realize $\mathcal{F}_\mathsf{pake}$ in the $\mathcal{F}_{\mathsf{crs}}$-hybrid model.
	\end{theorem}

	\begin{proof}
	
	Consider the environment $\env$ in \Cref{fig:adv} and the dummy adversary. It follows from the correctness of the protocol that in the real-world protocol execution $\env$ always outputs $1$, since the algorithm of $\env$ and $\adv$ is the same as that of an honest server. At a high level, we will show that any simulator that successfully simulates the protocol against $\env$ in the ideal world can be used to solve arbitrary instances of fixed-CDH.\\
	
	\begin{figure}[h]
		\begin{framed}
% [
%			linecolor=black,
%			linewidth=1pt,
%			roundcorner=5pt,
%			backgroundcolor=white,
%			userdefinedwidth=\textwidth,
%			]
			\vspace{2mm}
			\textbf{\underline{Environment $\env$:}}
			\begin{enumerate}
				\item $\env$ selects $\pw\xleftarrow{\$}\mathcal{PW}$, where $\mathcal{PW}\subseteq\mathbb{G}$ is the password dictionary. It then sends $(\newsession,\mathsf{sid},\user,\server,\pw)$ to $\user$.
				\item $\env$ receives $\msg{1} = \mathsf{sid}|\mathsf{VK}|A|B|C|D$ from $\adv$ and samples $x_2, y_2, z_2, w_2, r_2\xleftarrow{\$}\mathbb{Z}_q$. It then sets 
				\begin{align*}
					\alpha'&:=H(A|B|C|D)\\
					E &:= g_1^{x_2}g_2^{y_2}h^{z_2}(cd^{\alpha'})^{w_2}\\
					F &:= g_1^{r_2}\\
					G &:= g_2^{r_2}\\
					I &:= h^{r_2}\cdot\pw\\
					\beta &:= H(\msg{1}|E|F|G|I)\\
					J &:= (cd^{\beta})^{w_2}
				\end{align*}
			and instructs $\adv$ to send $\msg{2} = \mathsf{sid}|E|F|G|I|J$ to $\user$. 
			\item $\env$ receives $\msg{3}=\mathsf{sid}|K|\mathsf{Sig}$ from $\adv$ and $(\mathsf{sid}, \sk)$ from $\user$.
			\item $\env$ sets $C'=C/\pw$ and then checks if $\mathsf{Vrfy}_{\mathsf{VK}}(\msg{1}|\msg{2}|K,\mathsf{Sig})=1$. If yes, it computes $\sk_S=A^{x_2}B^{y_2}(C')^{z_2}D^{w_2}K^{r_2}$ and outputs $1$ if $\sk_S=\sk$. If either of the two checks fails, it outputs $0$.
			\end{enumerate}
			\vspace{2mm}
		\end{framed}
		\caption{Our Setup.}
		\label{fig:adv}
	\end{figure}

	Assume that there exists a negligible function $\varepsilon:=\varepsilon(\lambda)$ such that there exists a simulator $\simulator$ for which $\env$ outputs $1$ with probability $1-\varepsilon$ in the ideal world. Before the formal execution of the protocol begins, $\simulator$ samples $\mathsf{crs}=(\mathbb{G}; g_1, g_2, h, c, d\in\mathbb{G}; H:\{0,1\}^{*}\rightarrow\mathbb{Z}_q)$. First, assume that CDH is hard over $(\mathbb{G}, p, h)$. Given any two elements $(h^a, h^b)$ where $a,b\rgets\mathbb{Z}_p$, consider any reduction $\mathcal{R}$ which does the following.\\
	
	\nam{I'm not completely convinced if this is the best way to write this; the proof is correct in the essentials, but I think this needs to be rewritten since I'm not sure what formal part $\mathcal{R}$ is playing here...}
	
	\begin{enumerate}
		\item $\mathcal{R}$ sends $(\newsession,\mathsf{sid}, \user, \server)$ to $\simulator$.
		\item $\mathcal{R}$ waits to receive $\msg{1} = \mathsf{sid}|\mathsf{VK}|A|B|C|D$ in response. It sets $\pw=C/h^b$ and samples $x_2,y_2,w_2,r_2\rgets\mathbb{Z}_q$, setting
		\begin{align*}
			\alpha'&:=H(PIDs|A|B|C|D)\\
			E &:= g_1^{x_2}g_2^{y_2}h^{a}(cd^{\alpha'})^{w_2}\\
			F &:= g_1^{r_2}\\
			G &:= g_2^{r_2}\\
			I &:= h^{r_2}\cdot\pw\\
			\beta &:= H(\msg{1}|Server|E|F|G|I)\\
			J &:= (cd^{\beta})^{w_2}
		\end{align*}
		i.e., the same computation as that of the honest server with a special choice of $\pw$ and $z_2$ and sends $\msg{2}=\mathsf{sid}|E|F|G|I|J$ to $\simulator$.
		\item $\mathcal{R}$ receives $K|\mathsf{Sig}$ and checks if $\mathsf{Vrfy}_\mathsf{VK}(\msg{1}|\msg{2}|K,\mathsf{Sig})=1$. If yes, it receives $\sk_C$ from $\simulator$, and calculates 
		$$h'=\frac{\sk_C}{A^{x_2}B^{y_2}D^{w_2}K^{r_2}}.$$
		\item $\mathcal{R}$ outputs $h'$.		
	\end{enumerate}

		We recall that $\sk_C=\sk_S$ with probability $1-\varepsilon$ by the assumption. Clearly in the protocol execution, we have, setting $C'=C/\pw=h^b$,
		$$\sk_S = A^{x_2}B^{y_2}(C')^{z_2}D^{w_2}K^{r_2}=A^{x_2}B^{y_2}(h^b)^{a}D^{w_2}K^{r_2}$$ which clearly gives $h' = h^{ab}$ with probability $1-\varepsilon$, as claimed.\\
	
	
	\textcolor{gray}{//everything below is deprecated comments.}\\

	
	First, we will assume the hardness of CDH over the group $(\mathbb{G},g,p)$. Let Let $g^a,g^b$ be two elements where $a,b\xleftarrow{\$}\mathbb{Z}_p$. 
	
	Formally, assume that there exists a simulator $\simulator$ such that $\env$ always outputs $1$ in the ideal world. \xjy{Formally we cannot really assume this; need to say ``such that $\env$ outputs $1$ with all but negligible probability in the ideal world''. I am not entirely sure for now, but we probably need to be more specific and say ``there is a negligible function $\epsilon$ such that $\env$ outputs $1$ with probability $1-\epsilon$ in the ideal world.''} We will use this simulator to compute $g^{ab}$. \xjy{We will construct a reduction $\mathcal{R}$ that uses $\simulator$ to solve the CDH problem in $(\mathbb{G},g,p)$. (I think it's better to explicitly mention a reduction.)} Our technique works as follows: first, we send \xjy{everywhere you say ``we do something'', change it to ``$\mathcal{R}$ does something''} $(\newsession,\mathsf{sid},\user,\server,\pw)$ to $\pake$ \xjy{conceptually I think $\mathcal{R}$ should play the role of $\pake$ (if you are not sure what I am talking about, chat with me in our meeting or on Slack)} and recieve $\msg{1} = \mathsf{sid}|\mathsf{VK}|A|B|C|D$ in response from $\simulator$. We set $\pw = C/g^b$ and sample $x_2,y_2,z_2,w_2,r_2\xleftarrow{\$}\mathbb{Z}_q$. 
	\begin{align*}
		\alpha'&:=H(PIDs|A|B|C|D)\\
		E &:= g_1^{x_2}g_2^{y_2}h^{z_2}(cd^{\alpha'})^{w_2}\\
		F &:= g_1^{r_2}\\
		G &:= g_2^{r_2}\\
		I &:= h^{r_2}\cdot\pw\\
		\beta &:= H(\msg{1}|Server|E|F|G|I)\\
		J &:= (cd^{\beta})^{w_2}
	\end{align*}
	i.e., the same computation as that of the honest server with a special choice of $\pw$. Forwarding this to $\pake$, we recieve $\msg{3}=K|\mathsf{Sig}$ and $(\mathsf{sid}, \sk)$ in return.
	
	\end{proof}
	
	
	
	\pagebreak
	\appendix
	
%	\bibliographystyle{alpha}
%	\bibliography{references}
	
\end{document}









