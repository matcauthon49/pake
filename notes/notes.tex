\documentclass[12pt,a4paper]{article}
\usepackage[margin=1in, includeheadfoot]{geometry}

\usepackage[dvipsnames]{xcolor}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
%\usepackage{makeidx}
\usepackage{thmtools}
\usepackage{graphicx}
\usepackage{hyperref}
\usepackage{tikz}
\usepackage{algpseudocode}
\usepackage{multirow}
\usepackage{framed}


\usetikzlibrary{positioning}

\usepackage{thmtools}
%\usepackage[skip=6pt]{parskip}

\usepackage{fancyhdr}
\pagestyle{fancy}

\fancyhead[L]{\textbf{KOY is not UC-Secure}}
\fancyhead[R]{\thepage}
\fancyfoot{}

\setlength\parindent{0pt}

\hypersetup{
	colorlinks=true,
	linkcolor=red,
	filecolor=red,  
	citecolor=red,    
	urlcolor=blue,
	pdftitle={Games on Graphs \#1},
	pdfpagemode=FullScreen,
}

% \usepackage[framemethod=tikz]{mdframed}

\declaretheorem[name=Theorem, numberwithin=section]{theorem}
\declaretheorem[name=Lemma, numberwithin=section]{lemma}
\declaretheorem[name=Inequality, numberwithin=section]{inequality}
\declaretheorem[name=Definition, numberwithin=section]{definition}

\usepackage[english]{babel}
\title{\textbf{KOY is not UC-Secure}}
\author{Naman Kumar}

%------- General Macros

\newcommand{\np}{\mathbf{NP}}
\newcommand{\p}{\mathbf{P}}
\newcommand{\ip}{\mathbf{IP}}
\newcommand{\pspace}{\mathbf{PSPACE}}
\newcommand{\am}{\mathbf{AM}}
\newcommand{\ma}{\mathbf{MA}}
\newcommand{\F}{\mathbb{F}}
\newcommand{\E}{\mathbb{E}}
\newcommand{\rel}{\mathcal{R}}
\newcommand{\lang}{\mathcal{L}}
\newcommand{\query}{\mathcal{Q}}
\newcommand{\prover}{\mathcal{P}}
\newcommand{\verifier}{\mathcal{V}}
\newcommand{\decision}{\mathcal{D}}
\newcommand{\simulator}{\mathcal{S}}
\newcommand{\sat}{\mathsf{SAT}}
\newcommand{\nc}{\mathbf{NC}}
\newcommand{\hvzk}{\mathbf{HVZK}}
\newcommand{\zk}{\mathbf{ZK}}
\newcommand{\pzk}{\mathbf{PZK}}
\newcommand{\czk}{\mathbf{CZK}}
\newcommand{\szk}{\mathbf{SZK}}
\newcommand{\pc}{\mathsf{pc}}
\newcommand{\vc}{\mathsf{vc}}
\newcommand{\vr}{\mathsf{vr}}
\newcommand{\poly}{\mathsf{poly}}
\newcommand{\add}{\mathsf{add}}
\newcommand{\mul}{\mathsf{mul}}
\newcommand{\view}{\mathsf{View}}
\newcommand{\trace}{\textsc{Trace}}
\newcommand{\bpp}{\mathbf{BPP}}
\newcommand{\hilbert}{\mathcal{H}}
\newcommand{\ket}[1]{\left|#1\right\rangle}
\newcommand{\bra}[1]{\left\langle#1\right|}
\newcommand{\braket}[2]{\langle#1|#2\rangle}
\newcommand{\puncture}{\mathsf{Puncture}}

%---------- Macros

\newcommand{\env}{\mathcal{Z}}
\newcommand{\adv}{\mathcal{A}}
\newcommand{\pake}{\mathcal{F}_{\mathsf{PAKE}}}
\newcommand{\user}{\mathsf{User}}
\newcommand{\sk}{\mathsf{sk}}
\newcommand{\pw}{\mathsf{pw}}
\newcommand{\crs}{\mathsf{crs}}
\newcommand{\newsession}{\mathsf{NewSession}}
\newcommand{\testpwd}{\mathsf{TestPwd}}
\newcommand{\server}{\mathsf{Server}}
\newcommand{\msg}[1]{\mathsf{msg}_{#1}}


\begin{document}
	\maketitle
	
	This document contains a proof that the PAKE protocol of Katz, Ostrovsky and Yung (2001) is not UC-secure.
	
	\section{Overview}
	
	At a high level, our attack relies on an adversary that completely disregards the presence of the $\server$ and instead interacts with the $\user$ while executing the Server's algorithm on its own. In particular, once the protocol is initiated by $\user$, the adversary assumes the role of the server (discarding the actual server in the process, which plays no part in the protocol henceforth) and recieves $\msg{1}$. After this, $\adv$ is provided the messages $E|F|G|I|J$ by $\env$ which it then forwards to $\user$. $\user$ can then run its own session-key generating algorithm (the computation of $E^{r_1}F^{x_1}G^{y_1}(I')^{z_1}J^{w_1})$ and output the session key $\sk$. We note that at this point, $\adv$ and $\env$ have all the information they need to run the server algorithm and ensure that their generated session key is equal to the $\sk$ generated by $\user$.
	
	To see why $\simulator$ cannot simulate this adversary, we attempt an ideal-world execution and pinpoint where our simulation fails. Since $\simulator$ is allowed to choose the $\crs$, it can sample $g_1$ at random and set $h$ such that $h={g_1}^{\ell}$. After receiving the $\newsession$ command from $\pake$, $\simulator$ must simulate the $\user$ by sampling fresh randomness and computing $\msg{1}$. Since $\simulator$ does not know the password at this point it must guess some $\pw^{*}$ at random. Thus, in $\msg{1}$, $C=h^{r_1}\cdot\pw^{*}$ where $\pw^{*}$ can be no better than a random password sampled from the dictionary. $\simulator$ must then forward this message to $\env$ which responds with $E|F|G|I|J$ where  $\pw$ can be determined as $I/F^\ell$. Once this has been done, $\simulator$ can run a $\testpwd$ which would successfully allow it to choose the $\sk$ output by $\user$ (recall that a $\testpwd$ \textit{must} be run, since we require that $\msg{1}$ and $\msg{2}$ together with the randomness of the $\user$ and $\adv$ together determine $\sk$; allowing the simulation to proceed without a $\testpwd$ would result in $\pake$ outputting a uniformly random key). The problem is that even with this information, $\simulator$ can still not determine what $\sk$ is.
	
	To determine $\sk$, $\simulator$ can either run $\server$'s algorithm or $\user$'s algorithm to generate session keys. Recalling that $E|F|G|I|J$ is provided to $\simulator$ directly from the environment, $\simulator$ cannot use $\server$'s algorithm since it would require the determination of all of $x_2, y_2, z_2, r_2, w_2$, which is computationally infeasible under the hardness of CDH. Alternately, $\simulator$ can run $\user$'s algorithm to determine $\sk$, for which it already has access to $x_1,y_1,z_1,r_1,w_1$ and $E,F,G,I,J$. However, we require that this $\sk$ output by the $\simulator$ must be equal to that which $\env$ determines using its own execution of the $\server$'s algorithm ($\env$ knows the randomness generated in the construction of $E|F|G|I|J$ and can thus run this algorithm). We can show that the output of the server's algorithm on $\msg{1},\msg{2}$ and $\msg{3}$ by $\env$ will have $(\pw^{*}/\pw)^{z_2}$ as a factor. Except in the $1/\mathcal{D}$ probability case that $\pw^{*}=\pw$, $\simulator$ cannot determine $z_2$ assuming the hardness of CDH and thus will be unable to determine $\sk$.\\
	
	\section{Proof}
	
	We will be working with the following environment and dummy adversary. We note that it follows from the correctness of the protocol that in the real-world protocol execution $\env$ always outputs $1$, since the algorithm of $\env$ and $\adv$ is the same as that of an honest server.\\
	
	\begin{figure}[h]
		\begin{framed}[
%			linecolor=black,
%			linewidth=1pt,
%			roundcorner=5pt,
%			backgroundcolor=white,
%			userdefinedwidth=\textwidth,
			]
			\vspace{2mm}
			\textbf{\underline{Environment $\env$:}}
			\begin{enumerate}
				\item $\env$ selects $\pw\xleftarrow{\$}\mathcal{PW}$, where $\mathcal{PW}\subseteq\mathbb{G}$ is the password dictionary. It then sends $(\newsession,\mathsf{sid},\user,\server,\pw)$ to $\user$.
				\item $\env$ recieves $\msg{1} = Client|\mathsf{VK}|A|B|C|D$ from $\adv$ and samples $x_2, y_2, z_2, w_2, r_2\xleftarrow{\$}\mathbb{Z}_q$. It then sets 
				\begin{align*}
					\alpha'&:=H(PIDs|A|B|C|D)\\
					E &:= g_1^{x_2}g_2^{y_2}h^{z_2}(cd^{\alpha'})^{w_2}\\
					F &:= g_1^{r_2}\\
					G &:= g_2^{r_2}\\
					I &:= h^{r_2}\cdot\pw\\
					\beta &:= H(\msg{1}|Server|E|F|G|I)\\
					J &:= (cd^{\beta})^{w_2}
				\end{align*}
			and forwards $\msg{2} = Server|E|F|G|I|J$ to $\adv$.
			\item $\env$ recieves $\msg{3}=K|\mathsf{Sig}$ from $\adv$ and $(\mathsf{sid}, \sk)$ from $\user$.
			\item $\env$ sets $C'=C/\pw$ and then checks if $\mathsf{Vrfy}_{\mathsf{VK}}(\msg{1}|\msg{2}|K,\mathsf{Sig})=1$. If yes, it calculates $\sk_S=A^{x_2}B^{y_2}(C')^{z_2}D^{w_2}K^{r_2}$ and outputs $1$ if $\sk_S=\sk$. Otherwise it outputs $0$.
			\end{enumerate}
			\textbf{\underline{Dummy Adversary $\adv$:}}
			\begin{enumerate}
				\item $\adv$ recieves $\msg{1} = Client|\mathsf{VK}|A|B|C|D$ from $\user$, which it forwards to $\env$.
				\item $\adv$ recieves $\msg{2}=E|F|G|I|J$ from $\env$ and sends it to $\user$.
				\item $\adv$ recieves $\msg{3}=K|\mathsf{Sig}$ and forwards this to $\env$.
			\end{enumerate}
			\vspace{2mm}
		\end{framed}
		\caption{Our Setup.}
		\label{fig:adv}
	\end{figure}
	
	
	
	First, we will assume the hardness of CDH over the group $\mathbb{G}$. Let $g$ be a generator and $(g^a, g^b)$ be two elements such that $a,b\xleftarrow{\$}\mathbb{F}_{|\mathbb{G}|}$. We will show that any UC-simulator $\simulator$ that successfully simulates $\adv$ in $\pake$ can be used to compute $g^{ab}$.
	
	Formally, assume that there exists a simulator $\simulator$ such that $\env$ always outputs $1$ in the ideal world. We will use this simulator to compute $g^{ab}$. Our technique works as follows: first, we send $(\newsession,\mathsf{sid},\user,\server,\pw)$ to $\pake$ and recieve $\msg{1} = Client|\mathsf{VK}|A|B|C|D$ in response from $\simulator$. We set $\pw = C/g^b$ and sample $x_2,y_2,z_2,w_2,r_2\xleftarrow{\$}\mathbb{Z}_q$. 
	\begin{align*}
		\alpha'&:=H(PIDs|A|B|C|D)\\
		E &:= g_1^{x_2}g_2^{y_2}h^{z_2}(cd^{\alpha'})^{w_2}\\
		F &:= g_1^{r_2}\\
		G &:= g_2^{r_2}\\
		I &:= h^{r_2}\cdot\pw\\
		\beta &:= H(\msg{1}|Server|E|F|G|I)\\
		J &:= (cd^{\beta})^{w_2}
	\end{align*}
	ie. the same computation as that of the honest server with a special choice of $\pw$. Forwarding this to $\pake$, we recieve $\msg{3}=K|\mathsf{Sig}$ and $(\mathsf{sid}, \sk)$ in return.
	
	
	
	
	
	\pagebreak
	\appendix
	
%	\bibliographystyle{alpha}
%	\bibliography{references}
	
\end{document}









