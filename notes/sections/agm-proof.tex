\section{UC-Security of KOY in the Algebraic Group Model}

We will show the following theorem.

\begin{theorem}
	The protocol of \cref{fig:koy} UC-realizes the $\pake$ functionality in the Algebraic Group Model under the SDH and DDH Assumptions.
\end{theorem}

\subsection{Notation}

Before we proceed, we describe some notation and terminology. Our proof will proceed via a sequence of hybrids. We will show that the advantage of the adversary in game $\game_0$ (which corresponds to the real-world attack) is at most negligibly greater than that of the adversary in game $\game_9$, which corresponds to the ideal world.

Let $Z_i$ denote the event that $\mathcal{Z}$ outputs $1$ in game $G_i$. We need to show that $Z_0\cong Z_9$, which corresponds to the fact that the real world attack is indistinguishable from the ideal world attack.

We refer to the system of $\party_0$ and $\party_1$ as the \textit{challenger}. The challenger plays the role of $\user$ and $\server$ and carries out all interactions with the adversary (and hence, the environment).

Let $\msg{i}$ denote the $i$th message output by the challenger. This message is relayed to the adversary, and the (algebraic) adversary responds with a message $\msg{i}^{*}$ along with a message $\msg{i}^{'*}$ which is an algebraic representation of the elements it has seen so far. 


\subsection{Overview}

The broad strokes of our proof are as below.

\begin{enumerate}
	\item In game $\game_0'$, the experiment is aborted if any of the following events happen.
	\begin{enumerate}
		\item A $\VK$ is reused. In this case, the challenger detects this in the message that is output, sends an $\abort$ and ends the protocol.
		\item The server generates $\msg{2}$ twice for different $\sid$s. The challenger detects this in the message that is output, sends an $\abort$ and ends the protocol.
		\item The challenger detects at some point that the adversary has been able to produce a new signed message for some honestly-generated $\VK$ without knowing the corresponding signing key (which it can't, because the $\VK$ is honestly generated -- if it was the one who generated that $\VK$, the adversary is allowed to do whatever it wants with it).
		\item At any given point, the challenger detects that a collision has occured in the hash function. In this case the challenger again sends an $\abort$ and terminates the protocol.
	\end{enumerate}
	This is indistinguishable from the attack $\game_0$ because the probability of any of these events happening is unlikely due to the security of the hash functions and the one-time signature scheme.
	
	\item In game $\game_1$, the challenger changes the way that the $\crs$ is generated. In this case, the $\crs$ is now generated according to the techniques laid out in the Cramer-Shoup $\keygen$ procedure. The distribution of generated values is information-theoretically identical; the only difference is that now the challenger has planted trapdoors into the description of the $\crs$, and it knows the discrete logs of $h, c$ and $d$. The simulator is going to (eventually) use this to extract a password guess.
	
	\item In game $\game_2$, the challenger considers the messages $\msg{i}^{*}$ received from the adversary, and uses the parameters in $\game_1$ to extract a password guess. If the password guess is correct, it extracts the computed session key in the compromised protocol and sets it to be $\sk_i$. Note that the change is purely conceptual; the game is indistinguishable from the previous one. The extraction of $\sk_i$ requires us to use the algebraic exponents delivered by the adversary; this part of the proof requires the AGM.
	
	\item In game $\game_3$, the challenger deals with incoming $\msg{3}^{*}$ queries. It checks the $\sid$ of the message and in case that $\msg{1} = \msg{1}^{*}$, it sets $\sk_\server:=\sk_\user$ for the same $\sid$, which was already previously computed (at the time that $\msg{3}$ was output).  Note that in this case $\msg{3}$ \textit{has} to be output by the client -- the only situation in which this doesn't happen is if the environment was able to forge some $(K,\mathsf{sig})$, but $\game_0'$ necessitates abort in the case that this occurs. Thus, the game is valid, and furthermore is indistinguishable because this is, again, only a conceptual change.
	
	\item In game $\game_4$, the challenger again deals with incoming $\msg{3}^{*}$ queries. It again checks the $\sid$ of the message and in the case that $\msg{1}\neq\msg{1}^{*}$ and furthermore the message is an invalid Cramer-Shoup ciphertext of $\pw_\user$, the challenger outputs a session key $\sk_\server$ \textit{at random}. The proof of indistinguishability proceeds from an information-theoretic argument.
	
	\item In game $\game_5$, the challenger replaces the server's Cramer-Shoup encryption of $\pw_\user$ with an encryption of some $g^k\notin\mathcal{PW}$. The proof of indistinguishability follows from the fact that any environment which can differentiate between the two games can also be used as a subroutine to break the CCA-security of Cramer-Shoup.
	
	\item In game $\game_6$, the challenger considers $\msg{2}^{*}$. If $\msg{2}^{*}=\msg{2}$, then the challenger sets $\sk_\user$ to be random. The proof of this game is similar to that of $\game_3$.
	
	\item In game $\game_7$, the challenger considers $\msg{2}^{*}$ again, and the case in which $\msg{2}^{*}\neq\msg{2}$ but the message does not contain a valid password guess, it sets $\sk_\user$ to be random as well. The proof is again similar.
	
	\item In game $\game_8$, the challenger replaces the client's Cramer-Shoup encryption of $\pw_\user$ with an encryption of some $g^k\notin\mathcal{PW}$. The proof of indistinguishability follows from the DR-CCA security of Cramer-Shoup, which is discussed in \cref{appendix-a}.
	
	\item Game $\game_9$ is the ideal functionality. We argue that the structure of $\game_8$ can be interpreted as the ideal functionality with no security loss.	
\end{enumerate} 


\subsection{Proof of UC-Security}

We now provide a formal description of the proof.

\textbf{Game $\game_0$.} This game corresponds to the real-world attack.

\textbf{Game $\game_0'$.} In this game, the challenger interacts with the adversary as before, except we introduce an additional abort clause. If this clause is activated, then the challenger sends a message $\abort$ and ends the protocol. The abort clause is activated in the case of the following situations:
\begin{enumerate}
	\item The verification key $\VK$ is used more than once by the system. This encompasses the case when the client's generation algorithm outputs $\VK$ twice for two separate instantiations in two separate sessions.
	\item The server generates a $\msg{2}$ which is identical to a different $\msg{2}$ generated in a separate session.
	\item Consider $(\SK,\VK)$ to be honest outputs of $\OTS.\keygen(1^\secpar)$ by the client. Then if the adversary is able to output some $\mathsf{sig}'$ which was \textit{not} generated by the challenger using the signing algorithm, and $\mathsf{Vrfy}_\VK(\mathsf{sig}')=1$. 
	\item A collision occurs in the hash function.
\end{enumerate}

We will show that the probability of each of these cases is negligible. 

For $(2)$, this is information-theoretic: the only way this can happen is if the selected exponents repeated, which occurs with negligible probability in $\secpar$. 

$(4)$ occurs with negligible probability by the collision-resistance of the hash function $\mathsf{HF}$.

Case $(1)$ and $(3)$ occur with negligible probability by fact that $\OTS$ is a one-time signature scheme.


It follows that $$\Pr[Z_0] \leq \Pr[Z_0']+\negl(\secpar).$$

\textbf{Game $\game_1$.} In this game, the challenger changes the way that $\crs$ is sampled. In particular, it uses the following initialization algorithm described in \cref{fig:initialization-game-1}. Note that the initialization algorithm closely resembles that of the setup of the Cramer-Shoup encryption scheme.

\begin{figure}[h]
	\FrameSep5pt
	\begin{framed}\small
		\textbf{Initialization}: Let $\Gamma[\hat{\G},\G,g,q]\rgets[S_\secpar]$. Set $g_1\gets g$, $g_2\rgets\overline{\G}$. Choose $$\kappa\rgets\Z_q^{*}; (\chi_1,\chi_2),(\zeta_1,\zeta_2)\rgets\{(x,y)\in\Z_p^2:g_1^xg_2^y\neq 1\}$$ and set $h:=g_1^\kappa$, $c:=g_1^{\chi_1}g_2^{\chi_2}$ and $d:=g_1^{\zeta_1}g_2^{\zeta_2}$. Furthermore, $\hk\rgets\mathsf{HF.Keyspace}_{\lambda,\Gamma}$. Output $\crs = (\Gamma,g_1, g_2,h,c,d,\hk)$.
	\end{framed}
	\caption{Challenger's modified initialization algorithm in $\game_1$.}
	\label{fig:initialization-game-1}
\end{figure}

Note that the distribution of $\crs$ in $\game_1$ and $\game_0'$ is identical. The only elements which are chosen differently are $h, c$ and $d$, however their distribution is still uniform in $\overline{\G}$. Thus, it follows that $$\Pr[Z_0'] = \Pr[Z_1].$$

Before we continue, we introduce some additional, helpful terminology. 

\begin{enumerate}
	\item If $\msg{i}^{*}\neq\msg{i}$, we say that it is \textit{adversarially-generated}.
	\item Consider $\msg{1}^{*}$. If either $A^{\chi_1+\alpha\zeta_1}B^{\chi_2+\alpha\zeta_2}\neq D$ or $C/\pw_\user\neq A^\kappa$, then $\msg{1}$ is \textit{invalid}, otherwise it is \textit{valid}.
	\item Consider $\msg{2}^{*}$. If either $F^{\chi_1+\alpha\zeta_1}G^{\chi_2+\alpha\zeta_2}\neq J$ or $I/\pw_\user\neq F^\kappa$, then $\msg{1}$ is \textit{invalid}, otherwise it is \textit{valid}.
\end{enumerate}

\textbf{Game $\game_2$.} In this game, the challenger makes two changes. After this game, the password will no longer be used in computing the session key, except implicitly.

When the challenger receives $\msg{2}^{*}$, it examines it. In the case that $\msg{2}^{*}$ is adversarially-generated and valid, it considers the adversary's algebraic exponents $(x_2,y_2,z_2,w_2,r_2)$, which were provided along with $\msg{2}^{*}$. It then computes $$C':= \frac{C}{I/h^{r_2}}$$ and sets the session key $\sk_\user = A^{x_2}B^{y_2}(C')^{z_2}D^{w_2}K^{r_2}$. The challenger then responds to the message with $\msg{3}^{*}$ exactly as it does in $\game_1$. 

When the challenger receives $\msg{3}^{*}$, it examines $\msg{1}^{*}$. If $\msg{1}^{*}$ is adversarially generated and valid, it considers $\msg{2} = (\sid, E, F, G, H, I)$ and the adversary's algebraic exponents output with $\msg{3}^{*}$ and $\msg{1}^{*}$ as $(x_1,y_1,z_1,w_1,r_1)$. If $\mathsf{Vrfy}_\VK(\msg{1}\|\msg{2}\|K,\mathsf{sig})=1$, it computes $$I':= \frac{I}{C/h^{r_1}}$$ and sets the session key $\sk_\user = E^{r_1}F^{x_1}G^{y_1}(I')^{z_1}J^{w_1}$.

\begin{lemma} We have
	$$\Pr[Z_1]=\Pr[Z_2].$$
\end{lemma}

\begin{proof}
	It is clear that the distribution on the adversary's (and environment's) view until an adversarially-generated and valid message is detected is identical. In the case such a message \textit{is} detected, note that by correctness of the protocol of \cref{fig:koy} we have
	\begin{align*}
		\frac{C}{I/h^{r^2}} = \frac{C}{\pw_\user}\\
		\frac{I}{C/h^{r^2}} = \frac{I}{\pw_\user}
	\end{align*}
	and hence $$A^{x_2}B^{y_2}(C')^{z_2}D^{w_2}K^{r_2} = E^{r_1}F^{x_1}G^{y_1}(I')^{z_1}J^{w_1}.$$ Thus there is no difference in the distribution of $\sk_i$ between $\game_1$ and $\game_2$, and the proposition follows.
\end{proof}

\textbf{Game $\game_3$.}