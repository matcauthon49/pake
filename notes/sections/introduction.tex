\section{Introduction}
A \emph{Password-Authenticated Key Exchange (PAKE)} protocol allows two parties to jointly establish a cryptographic key, where the only information shared in advance is a low-entropy string called the \emph{password}. Crucially, PAKE protocols must be secure against man-in-the-middle attackers in the \emph{password-only setting}, where no PKI is used. Such protocols have seen increasing interests in recent years, and are interesting from both theoretical and practical perspectives: with the standardization process by the IETF in 2019--20, PAKE is beginning to see broad applications in real life; and theoretically speaking, PAKE ``enhances'' the entropy of a shared secret from a low-entropy password to a high-entropy key, whose construction involves a number of technically interesting techniques and has boosted the development of some underlying primitives such as \emph{Smooth-Projective Hash Functions (SPHFs)}.

\paragraph{Two paradigms of PAKE construction.}
The vast majority of PAKE protocols in the literature fall into one of two main paradigms. The first one, starting from the Encrypted Key Exchange (EKE) protocol \cite{SP:BelMer92}, generally involves each party sending its message in an unauthenticated key exchange protocol (such as Diffie--Hellman) encrypted under the password. Protocols in this category include SPAKE1, SPAKE2 \cite{RSA:AbdPoi05}, and \xjy{FILL IN}. These protocols are generally extremely efficient but heavily rely on the Random Oracle Model (ROM); in some cases \cite{SP:BelMer92}, it requires an RO hash into a group, which might be hard to implement.

Another paradigm for PAKE construction makes use of SPHFs, and their security can be proven in the standard model where only a CRS is present. (PAKE in the ``plain'' model which does not even use a CRS is extremely difficult to construct and inefficient, and none of the existing protocols \cite{...} achieves any standard notion of security.) This line of PAKE protocols began with the seminal work of Katz, Ostrovsky and Yung \cite{EC:KatOstYun01} (henceforth KOY), which is one of the most thoroughly studied PAKE protocols: in particular, it has seen a number of followup works including generalization \cite{EC:GenLin03} and simplification \cite{PKC:AbdBenPoi15}, and extension to the threshold setting \cite{...}. Subsequent works following this paradigm include \cite{...} Aside from not requiring an RO, SPHF-based PAKE protocols also have reasonable efficiency; for example, the computational cost of the KOY protocol is roughly 4 times the cost of (unauthenticated) Diffie--Hellman.

\paragraph{PAKE security definition: game-based v. UC.}
Defining the security of PAKE protocols is a delicate task. There are a number of definitions in the literature, which can be divided into two types: game-based \cite{EC:BelPoiRog00,PKC:AbdFouPoi05} and Universally Composable (UC) \cite{EC:CHKLM05,C:ABBJKX20}. In multi-party computation, UC definitions are stronger than game-based definitions in general, as the former guarantees security under \emph{arbitrary composition} with other protocols; in PAKE, the UC definition has the additional advantage of modeling password reuse or correlated passwords across multiple protocol session. For these reasons, the UC definition has become the standard for PAKE security; in particular, all protocols that entered the second round of the IETF competition have a UC-security proof \cite{...}.

The UC definitions have been proven to imply the (standard) game-based definition (\cite[Appendix~A]{EC:CHKLM05} and \cite[Section~5]{C:ABBJKX20}). The reverse is not true, as there are a large number of PAKE protocols that are game-based secure but not UC-secure; in fact, the UC-security of \emph{all efficient PAKE protocols} involves one type of caveats or another. There has been no systematic study of the gaps between game-based and UC-security, but for all ``natural'' PAKE protocols that are game-based but not UC-secure, the reason seems to fall into one of the following two categories:
\begin{enumerate}
  \item \emph{EKE-type protocols}: UC-security requires a polynomial-time simulator to extract an adversary's password guess from protocol messages, and this ``extractability'' property is not required in game-based security. Take SPAKE2 as an example: there, both parties' protocol message is a Pedersen commitment to the password $C = g^x \cdot M^\pw$ (for random integer $x$ and random group element $M$ in the CRS), which information-theoretically hides the password. This means that even a computationally unbounded simulator cannot extract the password guess from the protocol message.\\
      There are two ways to salvage the UC-security of SPAKE2. First, the session key is derived from hashing the Diffie--Hellman key together with the password and the protocol transcript, which allows for password extraction \emph{after protocol session ends}. This means that SPAKE2 realizes a weaker ``lazy-extraction'' version of UC PAKE functionality, where password guess can be submitted by the simulator even after the session ends. This is the approach in \cite{C:ABBJKX20}; its deficiency is that it is unclear what type of forward secrecy this security notion provides. \\
      The other possibility is to analyze the UC-security of SPAKE2 in the \emph{Algebraic Group Model (AGM)} \cite{C:FucKilLos18}. Recall that in the AGM, the adversary $\adv$ is required to ``explain'' how it computed all group elements it outputs; that is, for any group element $Y$ output by $\adv$, $\adv$ needs to provide the \emph{algebraic coefficients} $\lambda_1,\dots,\lambda_n$ such that
      \[
      Y = X_1^{\lambda_1}\cdots X_n^{\lambda_n},
      \]
      where $X_1,\dots,X_n$ are group elements $\adv$ has seen so far. This means that in the AGM, when the adversary sends protocol message $C$, it must provide an ``explanation'' from which the password guess can be extracted immediately. The security of SPAKE2 in the AGM is shown in \cite{AC:ABKLX21}, which also proves that the UC composition theorem still holds in the AGM.
  \item \emph{SPHF-based protocols}: These protocols are not UC-secure for a completely different reason. In game-based security definition, the adversary ``wins'' the security game once it guesses the correct password, and all security guarantees are lost. By contrast, the UC definition requires the simulator to \emph{continue simulating the protocol even after a successful attack}; in particular, it must compute the session key of the attacked party and send this value to the UC PAKE functionality. In all SPHF-based PAKE protocols \cite{EC:KatOstYun01}, the simulator can extract the password guess but cannot compute the session key afterwards, because the password extraction happens ``too late''. \\
      To make SPHF-based PAKE protocols UC-secure (without introducing the ROM), \cite{EC:CHKLM05} modifies KOY by adding a ``pre-commitment'' to the password to allow for early extraction, as well as a zero-knowledge proof that the ``pre-commitment'' indeed commits to the correct password. This adds one round to the existing protocol, and drastically increases the computational cost. The most frustrating point is that the sole purpose of this ZK proof --- which destroys the efficiency of KOY\footnote{KOY requires 4 group exponentiations + 2 multi-exponentiations per party; the protocol in \cite{EC:CHKLM05} requires around 30 group exponentiations per party.} --- seems to be allowing the simulation to complete, and it is not even clear what exact attack this failure of UC-security implies. Indeed, the trick of adding a ZK proof has been called ``mysterious'' \cite{...}
\end{enumerate}
Given the success of the UC-AGM-security analysis of SPAKE2, a natural question arises:
\begin{displayquote}
\begin{center}
  \emph{Can we prove the UC-security of the original, reasonably efficient SPHF-based \\ PAKE protocols, in the AGM but without the ROM?}
\end{center}
\end{displayquote}

\paragraph{Our contributions.}
In this work, we perform a thorough study of the UC-(in)security of the KOY protocol and present two results. First, we prove that KOY is \emph{not} UC-secure, even in the ROM.\footnote{KOY uses a hash function where only collision-resistance is required; we show the UC-insecurity of KOY even if it is modeled as an RO.} The reason  --- as briefly discussed above --- has been explained intuitively \cite[Section~3.3]{EC:CHKLM05}, but we give the first formal proof of this result; in particular, we show that KOY is UC-insecure \emph{even if the simulator is computationally unbounded}, ruling out the possibility of proving the UC-security of KOY even in the weaker ``UC with angels'' framework.\footnote{UC with angels \cite{STOC:PraSah04} gives both the real adversary and the simulator access to an oracle (the ``angel'') that solves some hard problems such as DDH. It has been used in the security analyses of some asymmetric PAKE protocols such as SRP (the first PAKE protocol widely used in practice) \cite{CSF:DayLeh24}.} This forces us to use some other idealized models --- such as the AGM --- while considering the UC-security of KOY.

Second and more importantly, we prove that KOY (without the additional ZK proof) is UC-secure in the AGM, \emph{under a stronger assumption}. In particular, we show that the simulator is able to compute the attacked party's session key using the algebraic coefficients provided by the adversary, hence completing its simulation. This completes the picture of the UC-(in)security of KOY and renders it ``usable'' in the UC setting. Furthermore, our security analysis reveals some interesting nature of the UC-security definition for PAKE in general. In particular, there is a third gap between game-based and UC-security of PAKE which has never been noticed in the literature:
\begin{enumerate}\setcounter{enumi}{2}
  \item Even if the simulator can complete the simulation by simulating the attacked party's session key correctly, the environment might use this information to distinguish the \emph{previously simulated protocol messages} from the real messages. (Again, this issue does not emerge in the game-based setting, since the adversary simply ``wins'' the security game and does not need to proceed any further if its password guess is correct; this possibility is accounted for in the adversary's advantage allowed in the game-based definition.)
\end{enumerate}
Concretely, the game-based security of KOY holds under the DDH assumption, whereas the UC-AGM-security relies on the stronger Decisional Square Diffie--Hellman (DSDH) assumption, which says that given $g^x$ for random integer $x$, it is hard to distinguish $g^{x^2}$ from random. In fact, there is an explicit attack that renders KOY UC-insecure (even in the AGM) if DDH holds in the group but DSDH does not --- a surprising result that was unexpected by the authors.

\paragraph{ROM v. AGM: why does it matter?}
Given that the AGM is also an idealized model (like the ROM), one might ask why not simply use ROM-based PAKE protocols that are faster. Our primary answer is that \emph{the ROM and the AGM are very different idealized models in nature, with their respective advantages and disadvantages that are incomparable}. Security proofs in both the ROM and the AGM are heuristic arguments and do not provide iron-clad security guarantee; however, a proof in the AGM seems easier to interpret: people's faith in the ROM relies on the assumption that the hash function ``behaves like a random function'', whose exact meaning is unclear (in particular, it is hard to quantify how ``good'' SHA-3 is as an RO); by contrast, a proof in the AGM rules out a limited yet well-defined class of adversaries. In other words, our result shows that a successful attack on (the UC-security of) KOY must rely on some non-algebraic methods, where the adversary comes up with new group elements via means other than performing group operations on group elements it has seen. This provides more concrete guidance for both implementers and cryptanalysts.

In addition, (as mentioned above) KOY is one of the most well-studied PAKE protocols and represents a major paradigm of PAKE construction, so studying its exact security is of importance in its own right. Finally, the gaps between game-based and UC-security definitions for PAKE have always been a somewhat fuzzy topic, and as we have seen, the current understanding is incomplete; as a theoretical contribution, we hope to shed some light in this regard using KOY as a case study.

Our analysis of the UC-(in)security of KOY requires careful considerations of how the simulator can(not) be constructed. Below we first describe the KOY protocol, and then provide an informal but detailed overview of our technical argument.

\subsection{Protocol Description}
\xjy{Insert the description of KOY (revised to fit the UC formality) here.} \nam{I've made edits, clarified the scheme.}

We provide a high-level description of the protocol along with a sketch of the security proof below. Let $\G$ be an algebraic group in which DDH is believed to be hard and define $\crs := (g_1, g_2, h, c, d)$ to be uniformly sampled from $\G^5$; we set this to be the common random string. Note that $\crs$ can be interpreted to be a degenerate Cramer-Shoup public key with an unknown secret key.

\begin{itemize}
	\item $\user$ begins by generating a pair of keys $(\VK,\SK)$ for a one-time signature scheme and encrypts its password $\pw$ with label $\VK$ using the Cramer-Shoup public key embedded in the CRS. Let $H$ be a collision-resistant hash function and $r_1$ be the randomness used during encryption. The resulting ciphertext consists of four group elements $\ct_1 := (A,B,C,D) = (g_1^{r_1}, g_2^{r_1}, h^{r_1} \cdot\pw, (cd^\alpha)^{r_1})$ where $\alpha = H(\VK, A, B, C)$. $\user$ then sends $\msg{1} := (\VK, \ct_1)$ to $\server$. Note that $A$, $B$, $C' = C/\pw$, $D$ are all of the form $g^{r_1}$ where $g$ is some group element that $\server$ can compute, so they also serve as a message in a Diffie--Hellman-like protocol.
	
	\item Upon receiving $(\VK,A,B,C,D)$, the $\server$ samples its `Diffie--Hellman exponents' $(x_2, y_2, z_2, w_2)$, and computes $E = g_1^{x_2}g_2^{y_2}h^{z_2}(cd^\alpha)^{w_2}$.\footnote{Note that $\alpha = H(\VK|A|B|C)$, so $\server$ must wait for $\user$'s message before proceeding.} Furthermore, $\server$ encrypts $\pw$ with label $(\msg{1}, E)$ using Cramer--Shoup encryption as done by $\user$ in $\msg{1}$. Let $r_2$ be the randomness used in encryption. The resulting ciphertext is $\ct_2:=(F,G,I,J) = (g_1^{r_2}, g_2^{r_2}, h^{r_2} \cdot\pw, (cd^\beta)^{r_2})$. $\server$ sends $\msg{2} = (E,\ct_2)$ to $\user$.
	
	\item Symmetrically, $\user$ upon receiving $(E,\ct_2)$ samples its own `Diffie--Hellman exponents' $(x_1,y_1,z_1,w_1)$ and computes $K = g_1^{x_1}g_2^{y_1}h^{z_1}(cd^\beta)^{w_1}$. It signs the protocol transcript $\st = \sign_\SK(\msg{1}|\msg{2}|K)$, and sends $\msg{3} = (K, \st)$ to the server.
	
	\item $\server$ verifies the signature $\st$ and aborts if it is invalid. Otherwise the session key $\sk$ is defined as the product of
	\[
	X_1 = E^{r_1} = A^{x_2}B^{y_2}(C/\pw)^{z_2}D^{w_2}
	\]
	and
	\[
	X_2 = K^{r_2} = F^{x_1}G^{y_1}(I/\pw)^{z_1}J^{w_1}
	\]
	$\user$ can compute $X_1$ as $E^{r_1}$ and $X_2$ as $F^{x_1}G^{y_1}(I/\pw)^{z_1}J^{w_1}$, whereas $\server$ can compute $X_1$ as $K^{r_2}$ and $X_2$ as $F^{x_1}G^{y_1}(I/\pw)^{z_1}J^{w_1}$.
\end{itemize}

\paragraph{Security.}
To perform authentication, $\user$ and $\server$ need to (implicitly) prove to each other that they know $\pw$. This is achieved as follows. Note that $X_1 = E^{r_1} = A^{x_2}B^{y_2}(C/\pw)^{z_2}D^{w_2}$ has the following property: given $E$ (but not $x_2,y_2,z_2,w_2$), if $A|B|C|D$ is a valid encryption of $\pw$, then knowing the randomness $r_1$ is sufficient for computing $X_1$; otherwise $X_1$ is a uniformly random group element.\footnote{Using the terminology of SPHF: $(x_2,y_2,z_2,w_2)$ is the hash key and $E$ is the corresponding projection key; the function is defined as $\mathsf{Hash}_{(x_2,y_2,z_2,w_2)}(m) = A^{x_2}B^{y_2}(C/m)^{z_2}D^{w_2}$.} Therefore, an adversarial user that does not know $\pw$, is not able to come up with a valid $A|B|C|D$, so $X_1$ is uniformly random in the adversary's view (and so is $\sk = X_1X_2$); a symmetric argument can be made for an adversarial server. In the man-in-the-middle setting, an adversary can attempt to generate a valid ciphertext after seeing another valid ciphertext from the honest user/server, so we need the encryption scheme to be non-malleable (hence ElGamal does not suffice).

The one-time signature scheme effectively forces the adversary to pass $\msg{2}$ and $\msg{3}$ without modification as long as it passes $\msg{1}$. This is to prevent a man-in-the-middle adversary from gaining information by passing all ciphertexts but modifying the rest of the messages. Specifically, (if the signature scheme is removed) consider an adversary that passes $\msg{1} = A|B|C|D$, changes $\msg{2} = E|F|G|I|J$ to $E^{\frac{1}{2}}|F|G|I|J$, and changes $\msg{3} = K$ to $K^2$; this would cause $\sk_S = \sk_U^2$. In other words, the adversary (that does not know the password) causes the two parties' session keys to be unequal but correlated, which is not allowed by the security of PAKE. Furthermore, to prevent the adversary from plugging in its own verification key (and thus knowing the corresponding secret key), $\VK$ is included in the hash that produces $\alpha$. In this way if the adversary changes $\VK$ while keeping the ciphertext $A|B|C|D$, the ciphertext would become invalid.

\subsection{Technical Overview}

In this section, we provide a high-level explanation of why the KOY protocol is insecure in the UC framework, and how the AGM circumvents the difficulty for the UC simulator.

\paragraph{UC-insecurity of KOY.}
Our attack relies on an adversary $\adv$ that completely disregards the presence of $\server$ and instead interacts with $\user$ while executing $\server$'s algorithm on its own. In particular, once the protocol is initiated by $\user$, $\adv$ assumes the role of the server (discarding the actual server in the process, which plays no part in the protocol) and receives $\msg{1} = \mathsf{VK}|A|B|C|D$. After this, $\adv$ runs the server's algorithm on $\user$'s password $\pw$ (i.e., we assume that $\adv$ makes a correct password guess) and computes $\msg{2} = E|F|G|I|J$. $\user$ then runs its session-key generating algorithm and outputs its session key $\sk = E^{r_1}F^{x_1}G^{y_1}(I/\pw)^{z_1}J^{w_1}$. At this point, $\adv$ (and $\env$) have all the information they need to run the server's session-key generating algorithm locally, which computes a session key equal to $\sk$ generated by $\user$.

To see why a simulator $\simulator$ cannot simulate this adversary, we attempt an ideal-world execution and pinpoint where it fails. Since $\simulator$ is allowed to choose $\crs=(g_1, g_2, h, c, d)$, it can sample $g_1$ at random and set $h$ such that $h=g_1^{\ell}$ --- in other words, $\simulator$ chooses the ``CRS trapdoor'' $\ell = \log_{g_1} h$. After receiving the $\newsession$ command from $\pake$, $\simulator$ must simulate $\user$'s first message $\msg{1}$. Since $\simulator$ does not know the password, at this point it must (effectively) guess some $\pw'$ at random; that is, in $\msg{1}$, $C=h^{r_1}\cdot\pw'$ where $\pw'$ can be no better than a random password sampled from the dictionary. ($C$ is indistinguishable from the correct value due to the security of Cramer--Shoup encryption.) After $\env$ responds with $\msg{2} = E|F|G|I|J$, since $F = g_1^{r_2}$ and $I = h^{r_2} \cdot \pw$, $\simulator$ can extract $\pw$ as $I/F^\ell$. Once this has been done, $\simulator$ can send a $\testpwd$ command to $\pake$ on the correct $\pw$; $\pake$ would mark the $\user$ session $\compromised$ and thus allow $\simulator$ to choose $\user$'s session key $\sk$ (which has to be consistent with the session key $\user$ computes in the real world).\footnote{A $\testpwd$ \textit{must} be run, since we require that $\msg{1}$ and $\msg{2}$ together with the randomness of the $\user$ and $\adv$ together determine $\sk$; allowing the simulation to proceed without a $\testpwd$ would result in $\pake$ outputting a uniformly random key.} This is where the game-based security and UC-security of PAKE diverge: in game-based security, all security guarantees are considered lost (and the simulation of the game can stop) once the adversary guesses the correct password; whereas in UC-security the simulation has to continue. The problem here is that \emph{even knowing the correct password $\pw$, $\simulator$ still cannot determine what $\sk$ should be}.

Recall that $\sk$ is the product of
\[
X_1 = E^{r_1} = A^{x_2}B^{y_2}(C/\pw)^{z_2}D^{w_2}
\]
and
\[
X_2 = K^{r_2} = F^{x_1}G^{y_1}(I/\pw)^{z_1}J^{w_1}
\]
Computing $X_2$ is not a problem for $\simulator$, since $\msg{2} = E|F|G|I|J$ is provided to $\simulator$ directly from the environment; $\simulator$ chose $x_1, y_1, z_1, w_1$ on its own; and $\simulator$ has extracted $\pw$. However, $\simulator$ is not able to compute $X_1$. At first glance, computing $X_1 = E^{r_1}$ might appear feasible as $\simulator$ received $E$ as part of $\msg{2}$ and sampled $r_1$ before sending $\msg{1}$. However, the problem is that \emph{the password guess $\pw'$ that $\simulator$ uses while generating $\msg{1}$ is likely incorrect}; as a result, $E^{r_1}$ that $\simulator$ computes is actually equal to $A^{x_2}B^{y_2}(C/\pw')^{z_2}D^{w_2}$, whereas the correct value should be $A^{x_2}B^{y_2}(C/\pw)^{z_2}D^{w_2}$. This means that $\simulator$ must know $(\pw/\pw')^{z_2}$ in order to compute the correct $\sk$, which is infeasible unless $\pw'=\pw$ (whose probability is $1/\mathcal{|D|}$).

\paragraph{Simulating the session key in AGM.}
% By examining the game-based security proof of the KOY protocol, one can see that the above attack is essentially the only scenario where the UC-security can be broken; in particular, the cases where the adversary assumes the role of the user, as well as the adversary makes an incorrect password guess (by sending the Cramer--Shoup ciphertext of some $\pw^* \neq \pw$, or sending some group elements that are not a Cramer--Shoup ciphertext), can be simulated in UC without any issue. 

Our next critical observation is that the session key in the above attack can be simulated if we resort to the AGM, as the simulator $\simulator$ can extract $x_2, y_2, z_2, w_2$ from an algebraic environment. In more detail, suppose $\env$ runs the above attack and sends $E$ as part of $\msg{2}$. At this point all group elements that $\env$ has seen are $g_1,g_2,h,c,d$ from $\crs$, $A,B,C,D$ from $\msg{1}$, and $\pw$. An algebraic $\env$ must ``explain'' how $E$ is computed; for now let's ignore $A,B,C,D,\pw$ and assume $\env$ computes
\[
E = g_1^{x_2}g_2^{y_2}h^{z_2}(cd^\alpha)^{w_2}
\]
In the real world $\user$ would compute $X_1 = E^{r_1}$, which is equal to $A^{x_2}B^{y_2}(C/\pw)^{z_2}D^{w_2}$. In the ideal world, as explained above, $\simulator$ cannot compute $X_1$ as $E^{r_1}$ since it chose the wrong $\pw'$ with high probability while generating $A,B,C,D$; however, after extracting the correct $\pw$ from $\msg{2}$, $\simulator$ can still compute $X_1$ as $A^{x_2}B^{y_2}(C/\pw)^{z_2}D^{w_2}$, since now it sees the algebraic coefficients $x_2,y_2,z_2,w_2$ from $\env$. In this way $\simulator$ generates $X_1$ that is indistinguishable from the real world.

In the general case, suppose $\env$ computes
\[
E = g_1^{x_2}g_2^{y_2}h^{z_2}c^{w_2}d^{v_2}A^{x_2'}B^{y_2'}C^{z_2'}D^{w_2'}\pw^{p_2}
\]
In the real world $\user$ would compute
\begin{align*}
	X_1 &= E^{r_1} \\
	&= g_1^{r_1x_2} g_2^{r_1y_2} h^{r_1z_2} c^{r_1w_2} d^{r_1v_2} A^{r_1x_2'} B^{r_1y_2'} C^{r_1z_2'} D^{r_1w_2'} \pw^{r_1p_2} \\
	&= g_1^{r_1x_2} g_2^{r_1y_2} \left(\frac{C}{\pw}\right)^{z_2} c^{r_1w_2} d^{r_1v_2} A^{r_1x_2'} B^{r_1y_2'} C^{r_1z_2'} D^{r_1w_2'} \pw^{r_1p_2}
\end{align*}	
Again, in the ideal world $\simulator$ can compute $X_1$ according to the last equation; the key point is that given $A|B|C|D$, the only place where the ``wrong'' password $\pw'$ is used lies in $h$, so we only need to ``correct'' $h^{r_1}$ from $C/\pw'$ to $C/\pw$. A difference is that now the expression of $X_1$ involves the Cramer--Shoup randomness $r_1$, which is not a problem for $\simulator$ as $\simulator$ chose $r_1$ itself while sending $\msg{1}$. (Of course, we have $A = g_1^{r_1}$, so the $g_1^{r_1x_2} A^{r_1x_2'}$ part can be rewritten as $A^{x_2+r_1x_2'}$, and so on. But this simplification is not necessary.)

\paragraph{Further subtleties in UC.}
As we have just seen, one critical difference between game-based security and UC-security is that in UC indistinguishability between the real view and the simulated view must remain \emph{even when the environment sees the key of a successfully attacked session}, whereas in the game-based setting the adversary simply wins (and the simulator can ``give up'' on simulating the session key) once the attack on a session is successful. While the session key itself can be simulated in the AGM, this poses another potential issue that is more subtle: after seeing the session key, the environment might go back and check the validity of previous protocol messages using this information.

In more detail, assume again that the adversary interacts with $\user$ by running $\server$'s algorithm on $\user$'s password $\pw$. When $\user$'s session completes, the environment $\env$ sees $\user$'s session key $\sk_U = X_1X_2$ and the last message $\msg{3} = K|\sigma$. Since $\env$ can compute $X_2$ as $K^{r_2}$ (since $r_2$ is chosen by $\env$ itself), it can recover $X_1 = E^{r_1}$ (where $r_1$ is the randomness used in $\msg{1}$). Recall that in the ideal world the Cramer--Shoup ciphertext $A|B|C|D$ generated by the simulator $\simulator$ is an encryption of some $\pw'$ that is unlikely to be the ``correct'' $\pw$, so $\env$ must not be able to detect this fact even after seeing $E^{r_1}$. In other words, (very roughly) \emph{Cramer--Shoup must be secure even if the adversary sees $E^{r_1}$ for some $E$ of its choice}.

Below we analyze two simple attacks using this strategy:
\begin{enumerate}
	\item Say $\env$ chooses $E = A = g_1^{r_1}$; then $E^{r_1} = g_1^{r_1^2}$. If 2-DL is easy in the group\footnote{The 2-DL problem is: given $(g^x,g^{x^2})$ for $x \gets \mathbb{Z}_q$, compute $x$. We do not know the relative hardness between 2-DL and DDH, and it has been shown that 2-DL and CDH are separate in the AGM \cite{C:BauFucLos20}.}, then $\env$ can recover $r_1$ after $\user$'s session completes, and check if $C = h^{r_1} \cdot \pw$. In the real world this equation holds, whereas in the ideal world it does not if $\simulator$ chose the ``wrong'' $\pw' \neq \pw$ to encrypt while simulating $\msg{1}$. In fact, it seems that for the KOY protocol to be UC-AGM-secure, we need the \xjy{FILL IN} assumption. \xjy{I think the assumption should be Decisional Square Diffie--Hellman (DSDH), which says that given $g^x$, it is hard to distinguish $g^{x^2}$ from random. Note that this implies 2-DL (given $(g^x,Y)$ where $Y$ is either $g^{x^2}$ or random, the DSDH solver can feed $(g^x,Y)$ to the 2-DL solver and distinguish by observing whether the 2-DL solver wins or not)}
	\item Say $\env$ chooses $E = c$; then $E^{r_1} = c^{r_1}$. But Cramer--Shoup is obviously \emph{not} CCA-secure if the adversary additionally sees $c^{r_1}$. What saves us here is that $\env$ sees $E^{r_1}$ \emph{only at the end of $\user$'s session}. Indeed, the reduction $\red$ to the security of Cramer--Shoup roughly works as follows:
	\begin{enumerate}
		\item $\red$ embeds the challenge ciphertext as $\msg{1}$, $\user$'s first message intercepted by $\adv$;
		\item When $\adv$ sends $\msg{1}^*$ to $\server$ and $\msg{2}^*$ to $\user$, $\red$ needs to query the decryption oracle to extract the password guesses contained in these two messages;
		\item Finally, if the password guess in $\msg{2}^*$ is correct, $\red$ needs to simulate $\sk_U$. (This step is not needed in the game-based proof.)\footnote{We omit the remaining steps which are to simulate $\msg{3}$, and on $\msg{3}^*$ simulate $\server$'s session key $\sk_S$, as they are inconsequential to our main point.}
	\end{enumerate}
	$c^{r_1}$ is needed only in step (c), which happens after all decryption oracle queries have been made. Therefore, we only need Cramer--Shoup to remain CCA-secure if the adversary \emph{is restricted to making all decryption oracle queries before learning $c^{r_1}$}. We will show that Cramer--Shoup indeed satisfies this property in \xjy{FILL IN} \xjy{I think this should work, but it needs to be double checked}
\end{enumerate}
By inspecting the game-based security proof of the KOY protocol, one can see that the above attacks are essentially the only scenarios where the UC-security might be broken, and the security argument for all other cases (including the adversary sending a message that contains an incorrect password guess, or modifying the signature) is essentially identical to the game-based proof. \xjy{I hope so...} 